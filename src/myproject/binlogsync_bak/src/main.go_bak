package main

import (
	// "time"
//	"./domainmgr"
//	"./fdfs_client"
	"./logger"
//	"./sync"
//	"./tair"
	"encoding/json"
	"flag"
	"fmt"
//	"github.com/go-martini/martini"
	"io/ioutil"
	"os"
//	"time"
	"golang.org/x/net/context"
	"github.com/siddontang/go-mysql/replication"
	"github.com/siddontang/go-mysql/mysql"
	"github.com/siddontang/go-mysql/client"
)

var testHost = flag.String("host", "127.0.0.1", "MySQL master host")

type Config struct {
	LogPath         string   `json:"log_path"`  //各级别日志路径
	MysqlDsn        string   `json:"mysql_dsn"` //后台存储dsn
	MysqlIp         string   `json:"mysql_ip"`
	MysqlUserName   string   `json:"mysql_username"`
	MysqlPassword   string   `json:"mysql_password"`
	MsqlPort        uint16      `json:"mysql_port"`
	MysqlBackupList string   `json:"mysql_standby_list"`
	ListenPort      int      `json:"listen_port"` //监听端口号
	TrackerServer   []string `json:"tracker_server"`
	MinConnection   int      `json:"fdfs_min_connection_count"`
	MaxConnection   int      `json:"fdfs_max_connection_count"`
	TairClient      string   `json:"tair_client"`
	TairServer      []string `json:"tair_server"`
	ServerId        uint32   `json:"server_Id"`
	EachSyncNum     int      `json:"each_sync_num"`
	Dbconns         int      `json:"dbconns"`
	Dbidle          int      `json:"dbidle"`
}

func loadConfig(path string) *Config {
	if len(path) == 0 {
		panic("path of conifg is null.")
	}

	_, err := os.Stat(path)
	if err != nil {
		panic(err)
	}

	f, err := os.OpenFile(path, os.O_RDONLY, 0)
	if err != nil {
		panic(err)
	}
	var cfg Config
	b, err := ioutil.ReadAll(f)
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(b, &cfg)
	if err != nil {
		panic(err)
	}

	return &cfg
}

func main() {
	var cfg_path string
	flag.StringVar(&cfg_path, "conf", "../conf/conf.json", "config file path")
	flag.Parse()
	fmt.Println(cfg_path)

	cfg := loadConfig(cfg_path)

	l := logger.GetLogger(cfg.LogPath, "init")
	l.Infof("cluster backup start.")

	l.Infof("cluster backup start.%+v", cfg)

	cfgsql := replication.BinlogSyncerConfig {
	    ServerID: cfg.ServerId,
	    Flavor:   "mysql",
	    Host:     cfg.MysqlIp,
	    Port:     cfg.MsqlPort,
	    User:     cfg.MysqlUserName,
	    Password: cfg.MysqlPassword,
	}
	syncer := replication.NewBinlogSyncer(&cfgsql)
	
	c, err := client.Connect(fmt.Sprintf("%s:%d", cfg.MysqlIp, cfg.MsqlPort), cfg.MysqlUserName, cfg.MysqlPassword, "live_master")
    if err != nil {
            panic(err.Error())
    }

	r, err := c.Execute("SHOW MASTER STATUS")
    if err != nil {
            panic(err.Error())
    }
    
    binFile, _ := r.GetString(0, 0)
    binPos, _ := r.GetInt(0, 1)
       
	// Start sync with sepcified binlog file and position
	streamer, _ := syncer.StartSync(mysql.Position{binFile, (uint32)(binPos)})
	
	// or you can start a gtid replication like
	// streamer, _ := syncer.StartSyncGTID(gtidSet)
	// the mysql GTID set likes this "de278ad0-2106-11e4-9f8e-6edd0ca20947:1-2"
	// the mariadb GTID set likes this "0-1-100"
	
	for {
	    ev, _ := streamer.GetEvent(context.Background())
	    // Dump event
	    fmt.Println(ev)
	    ev.Dump(os.Stdout)
	}
	
	// or we can use a timeout context
//	for {
//	    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
//	    e, err := s.GetEvent(ctx)
//	    cancel()
//	
//	    if err == context.DeadlineExceeded {
//	        // meet timeout
//	        continue
//	    }
//	
//	    ev.Dump(os.Stdout)
//	}

//	d := logger.GetLogger(cfg.LogPath, "binlog")
//	r := logger.GetLogger(cfg.LogPath, "domainmgr")
//	c := logger.GetLogger(cfg.LogPath, "tair")
//	s := logger.GetLogger(cfg.LogPath, "sync")
//	f := logger.GetLogger(cfg.LogPath, "fdfs")
//
//	pBinlog := domainmgr.NewBinLogMgr(cfg.MysqlIp, cfg.MsqlPort, cfg.MysqlUserName,
//		cfg.MysqlPassword, cfg.ServerId, cfg.EachSyncNum, cfg.Dbconns, cfg.Dbidle, d)
//	if pBinlog == nil {
//		l.Errorf("NewBinLogMgr fail")
//		return
//	}
//
//	pStreaminfo := domainmgr.NewStreamMgr(cfg.MysqlDsn, cfg.MysqlBackupList, r)
//	if pStreaminfo == nil {
//		l.Errorf("NewStreamMgr fail")
//		return
//	}
//
//	pTair := tair.NewTairClient(cfg.TairServer, cfg.TairClient, c)
//	if pTair == nil {
//		l.Errorf("NewTairClient fail")
//		return
//	}
//
//	pClient, err := fdfs_client.NewFdfsClient(cfg.TrackerServer, f,
//		cfg.MinConnection, cfg.MaxConnection)
//	if err != nil {
//		l.Errorf("NewFdfsClient fail")
//		return
//	}
//
//	pSync := sync.NewSyncMgr(pStreaminfo, pBinlog, pTair, pClient, s)
//	if pSync == nil {
//		l.Errorf("NewSyncMgr fail")
//		return
//	}
//
//	go pSync.IncreaseSync()
//	go pSync.TotalSync()

//	m := martini.Classic()
	//m.Post("/checkdata", pSync.RecviveCheckData)
//	m.Post("/mysqlsync", pSync.ReceiveDbData)
	// m.Post("/receivebuff", pSync.ReceiveBuff)

//	m.Run()

	// time.Sleep(time.Second * 2)

	// m.Post("/receivefile", sync.ReceiveData)
	// m.Post("/sendfile", sync.SendData)

	// respUpload, err := client.UploadAppenderByFilename("/usr/local/sandai/tfdfs/bin/start_tairclient.sh")
	// if err != nil {
	// 	l.Infof("UploadAppenderByFilename fail")
	// 	return
	// }

	// l.Infof("UploadAppenderByFilename ok, %s, %s", respUpload.GroupName, respUpload.RemoteFileId)

	// respDownload, err1 := client.DownloadToBuffer(respUpload.RemoteFileId, 0, 513)
	// if err1 != nil {
	// 	l.Infof("DownloadToBuffer fail")
	// 	return
	// }

	// l.Infof("DownloadToBuffer ok, %s, %v, %d", respDownload.RemoteFileId,
	// 	respDownload.Content, respDownload.DownloadSize)

	//go pSync.IncreaseSync()
	// return
	// m := martini.Classic()
	// m.Post("/tair/pput", d_mgr.AddDevice)
	// m.Post("/dev/pget", d_mgr.AddDevice)
}
